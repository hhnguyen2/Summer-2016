## Define expit and dexpit
# expit: e^x/(1+e^x)
expit <- function(x){
exp(x)/(1+exp(x))
}
# dexpit: expit'(x), or expit(x)(1-expit(x))
dexpit <- function(x){
expit(x)*(1 - expit(x))
}
## gen_sim.data: Simulate data
## Output: a list of 2 objects:
##      - $eta: original eta values used to generate simulation data
##      - $sim.Matrix: n*p size matrix containing in order: (zi, 1, xi...)
gen_sim.data <- function(x){
n <- 1000
p <- 4
prob <- 0.5
eta_0 <- 1
eta <- signif(runif(4,-3,3),digits = 2)  # Generate random eta between -3,3 with 2 significant digits
randMatrix <- matrix(rbinom(n*p,1,prob),n,p) # x1, x2,...,xn
zi <- rbinom(n,1,expit(rowSums(sweep(randMatrix,MARGIN=2,eta,'*')) + eta_0)) # zi ~ expit(eta'*x + eta_0)
sim.Matrix <- cbind(zi,        # zi's
rep(1,n),     # x0
randMatrix)   # x1,x2,...,xn
return(list(eta=c(eta_0,eta),sim.Matrix=sim.Matrix))
}
## Solver
# Define function fr that evalutes f(eta)
fr <- function(eta, sim.Matrix){
# INPUTS: eta, with form (eta_0, eta_1, ..., eta_n)
# OUTPUTS: f(eta) as column vector
# ----------------
# Extract x1 to xn
xi <- sim.Matrix[,3:6] # x1, ..., x4
# Evaluate f(eta); eta[1] is eta_0
zi.minus.pi <- sim.Matrix[,1] - expit(eta[1] + rowSums(sweep(xi,MARGIN=2,eta[2:length(eta)],'*'))) # zi - xi*eta
# Output answer as column vector
as.matrix(colSums(sim.Matrix[,2:6] * zi.minus.pi))
}
# Define function grr that evalutes f'(eta)
grr <- function(eta, sim.Matrix){
# INPUTS: eta, with form (eta_0, eta_1, ..., eta_n)
# OUTPUTS: Inverse Jacobian of f(eta)
# ----------------
# Allocate empty answer matrix, should be 5x5
ans <- matrix(0,length(eta),length(eta))
ones.matrix <- matrix(1,length(eta),length(eta))
# Iteratively generate Jacobian matrix and add to allocated matrix
for (i in 1:nrow(sim.Matrix)){
# add.me is the Jacobian for a given row xi
add.me <- sweep(ones.matrix,MARGIN=1,sim.Matrix[i,2:6],'*')
add.me <- sweep(add.me,MARGIN=2,sim.Matrix[i,2:6],'*')
add.me <- -1 * add.me * dexpit(eta[1] + sum(sim.Matrix[i,3:6] * eta[2:5]))
# aggregate Jacobian from rows xi to answer matrix
ans <- ans + add.me
}
# Evaluate inverse Jacobian. Return NA matrix if singular.
tryCatch(solve(ans), error=function(e) matrix(NA,5,5))
}
## Newton Raphson to solve for eta
## INPUTS:  - eta_0, the initial guess
##          - real_eta, the eta used to generate the data (for end comparison)
##          - sim.Matrix, a matrix containing the simulation data of the form (zi, 1, xi...)
##
## OUTPUTS: - l2 norm of (real_eta - eta_0)
newtonRaphson <- function(eta_0,real_eta,sim.Matrix){
# Initial setup
count <- 0
max_iterations <- 100
# Set eta_t using eta_0 input, and then update eta_t.plus.one.
eta_t <- eta_0
eta_t.plus.one <- eta_t - (grr(eta_t,sim.Matrix) %*% fr(eta_t,sim.Matrix))
# Loop until squared diff between eta_t and eta_t.plus.one is minimized
#      or maximum alloted iterations is reached
while(count < max_iterations &&
norm(matrix(eta_t.plus.one - eta_t), "F") > .Machine$double.eps){
# Increment counter
count <- count + 1
# Update eta_t
eta_t <- eta_t.plus.one
eta_t.plus.one <- eta_t - (grr(eta_t,sim.Matrix) %*% fr(eta_t,sim.Matrix))
}
#cat("Total iterations: ", count, "\n",
#    "Eta_t.plus.one: ", eta_t.plus.one, "\n",
#    "Real eta: ", real_eta, "\n",
#    "Squared eta diff ", norm(real_eta - eta_t.plus.one), "F")
norm(eta_t.plus.one - real_eta,"F")
}
## Run the Newton-Raphson solver :)
iter <- 6                     # Number of times to loop Newton-Raphson solver
initial_eta <- c(0,0,0,0,0)   # Initial eta_0 guess
sqr_diffs <- rep(0,iter)      # Sqr_diffs contains the squared difference between eta_t and the real eta for each iteration i
ptm <- proc.time()            # Start system timer to see how slow the code is running
for (i in 1:iter){
# Generate simulation data. For each i, add the squared difference result from Newton-Raphson solver.
sim.data <- gen_sim.data()
sqr_diffs[i] <- sqr_diffs[i] + newtonRaphson(initial_eta,sim.data$eta,sim.data$sim.Matrix)
# Print out which step it is every 2 steps so I don't get that bored waiting
if (i %% 2 == 0)
print(i)
}
# Output data
proc.time() - ptm         # Time to run program
hist(sqr_diffs,breaks=15) # Generate histogram of squared differences with 15 bins
summary(sqr_diffs)        # Generate summary data: min, max, range, median, mode
cat("SD: ", sd(sqr_diffs), "\n") # Output the SD while we're at it.
